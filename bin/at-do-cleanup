#!/usr/bin/env ruby
#------------------------------------------------------------------------------
# Overview
#
# This script is designed to delete duplicate DigitalObject records from
# Archivist's Toolkit databases.
#
# Database connection parameters can be specified via the following
# environment variables:
#       AT_DB_HOST
#       AT_DB_USER
#       AT_DB_PASSWORD
#       AT_DB_DATABASE
#
# e.g.,
#
#   $ export AT_DB_HOST='localhost'
#   $ export AT_DB_USER='root'
#   $ export AT_DB_PASSWORD=''
#   $ export AT_DB_DATABASE='AT_BAZ_QUUX'
#
#------------------------------------------------------------------------------
require 'mysql2'
require_relative '../lib/at_do_cleanup'

include ATDOCleanup

class Cleaner
  attr_reader :client
  def initialize(args)
    @client = args[:client]
  end

  def clean!
    begin
      duplicate_records = get_duplicate_records(client: client)
      puts duplicate_records.count

      begin_transaction(client: client)
      process_duplicate_records(client: client, duplicate_records: duplicate_records)
    rescue StandardError, Mysql2::Error => error
      rollback_transaction(client: client)
      $stderr.puts error.message
      status = 1
    end
    rollback_transaction(client: client)
    status
  end

  private

  # get duplicate digital object records
  def get_duplicate_records(args)
    DigitalObject.find_duplicate_records(client: client)
  end

  def begin_transaction(args)
    puts "BEGIN TRANSACTION..."
    args[:client].query('START TRANSACTION')
  end

  def rollback_transaction(args)
    puts "ROLLBACK"
    args[:client].query('ROLLBACK')
  end

  def commit_transaction(args)
    puts "COMMIT"
    args[:client].query('COMMIT')
  end

  def get_authoritative_do(args)
    mets_id = args[:dupe].send(METS_ID_ATTR)
    results = DigitalObject.find_authoritative_record(client: args[:client], mets_id: mets_id)
    unless results.count == 1
      raise "ERROR: incorrect number of authoritative records (#{results.count}) for metsIdentifier #{mets_id}"
    end
    DigitalObject.new(results.first)
  end

  def assert_dupe(auth, dupe)
    raise 'dupe failed dupe? test' unless DigitalObject.dupe?(auth: auth, dupe: dupe)
  end

  def get_results(args)
    query = "SELECT * FROM #{args[:table]} WHERE #{args[:fk_attr]} = #{args[:fk_value]}"
    client.query(query)
  end

  def get_file_version_records(do_id)
    results = get_results(table:   'FileVersions',
                          fk_attr: 'digitalObjectId',
                          fk_value: do_id)
    if results.count < 1
      $stderr.puts "WARNING: incorrect number of FileVersion records (#{results.count}) for digitalObjectId =  #{do_id}"
    end
    results
  end

  def delete_file_versions(args)
    file_version_records = get_file_version_records(args[:dupe].send(DO_ID_ATTR))
    file_version_records.each do |r|
      fv = FileVersion.new(r)
      FileVersion.delete(client: args[:client], file_version: fv)
    end
  end

  def delete_arch_description_dates(args)
  end

  def delete_arch_description_subjects(args)
  end

  def delete_arch_description_names(args)
  end

  def delete_arch_description_repeating_data(args)
  end

  def delete_dupe(args)
    DigitalObject.delete(client: args[:client], digital_object: args[:dupe])
  end

  def process_dupe(args)
    auth = get_authoritative_do(args)
    assert_dupe(auth, args[:dupe])
    delete_file_versions(args)
    delete_arch_description_dates(args)
    delete_arch_description_subjects(args)
    delete_arch_description_names(args)
    delete_arch_description_repeating_data(args)
    delete_dupe(args)
  end

  def process_duplicate_records(args)
    args[:duplicate_records].each do |d|
      dupe = DigitalObject.new(d)
      process_dupe(client: args[:client], dupe: dupe)
    end
  end
end

def get_client(config = Config.new)
  # connect to db
  Mysql2::Client.new(host:     config.host,
                     username: config.user,
                     password: config.pass,
                     database: config.database)
end

#------------------------------------------------------------------------------
# main routine
#------------------------------------------------------------------------------
status = 0

cleaner = Cleaner.new(client: get_client)
status = cleaner.clean!
exit status

# begin
#   duplicate_records = get_duplicate_records(client: client)
#   puts duplicate_records.count

#   begin_transaction(client: client)
#   process_duplicate_records(client: client, duplicate_records: duplicate_records)
# rescue StandardError, Mysql2::Error => error
#   rollback_transaction(client: client)
#   $stderr.puts error.message
#   status = 1
# end
# # TEMPORARY
# rollback_transaction(client: client)
# exit status
